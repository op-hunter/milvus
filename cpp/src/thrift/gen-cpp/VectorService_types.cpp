/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "VectorService_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace zilliz {

int _kVecErrCodeValues[] = {
  VecErrCode::SUCCESS,
  VecErrCode::ILLEGAL_ARGUMENT,
  VecErrCode::GROUP_NOT_EXISTS,
  VecErrCode::ILLEGAL_TIME_RANGE,
  VecErrCode::ILLEGAL_VECTOR_DIMENSION,
  VecErrCode::OUT_OF_MEMORY
};
const char* _kVecErrCodeNames[] = {
  "SUCCESS",
  "ILLEGAL_ARGUMENT",
  "GROUP_NOT_EXISTS",
  "ILLEGAL_TIME_RANGE",
  "ILLEGAL_VECTOR_DIMENSION",
  "OUT_OF_MEMORY"
};
const std::map<int, const char*> _VecErrCode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kVecErrCodeValues, _kVecErrCodeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const VecErrCode::type& val) {
  std::map<int, const char*>::const_iterator it = _VecErrCode_VALUES_TO_NAMES.find(val);
  if (it != _VecErrCode_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}


VecException::~VecException() throw() {
}


void VecException::__set_code(const VecErrCode::type val) {
  this->code = val;
}

void VecException::__set_reason(const std::string& val) {
  this->reason = val;
}
std::ostream& operator<<(std::ostream& out, const VecException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t VecException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->code = (VecErrCode::type)ecast0;
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->reason);
          this->__isset.reason = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t VecException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("VecException");

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("reason", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->reason);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(VecException &a, VecException &b) {
  using ::std::swap;
  swap(a.code, b.code);
  swap(a.reason, b.reason);
  swap(a.__isset, b.__isset);
}

VecException::VecException(const VecException& other1) : TException() {
  code = other1.code;
  reason = other1.reason;
  __isset = other1.__isset;
}
VecException& VecException::operator=(const VecException& other2) {
  code = other2.code;
  reason = other2.reason;
  __isset = other2.__isset;
  return *this;
}
void VecException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "VecException(";
  out << "code=" << to_string(code);
  out << ", " << "reason=" << to_string(reason);
  out << ")";
}

const char* VecException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: VecException";
  }
}


VecGroup::~VecGroup() throw() {
}


void VecGroup::__set_id(const std::string& val) {
  this->id = val;
}

void VecGroup::__set_dimension(const int32_t val) {
  this->dimension = val;
}

void VecGroup::__set_index_type(const int32_t val) {
  this->index_type = val;
__isset.index_type = true;
}
std::ostream& operator<<(std::ostream& out, const VecGroup& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t VecGroup::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_dimension = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->dimension);
          isset_dimension = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->index_type);
          this->__isset.index_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dimension)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t VecGroup::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("VecGroup");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dimension", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->dimension);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.index_type) {
    xfer += oprot->writeFieldBegin("index_type", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->index_type);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(VecGroup &a, VecGroup &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.dimension, b.dimension);
  swap(a.index_type, b.index_type);
  swap(a.__isset, b.__isset);
}

VecGroup::VecGroup(const VecGroup& other3) {
  id = other3.id;
  dimension = other3.dimension;
  index_type = other3.index_type;
  __isset = other3.__isset;
}
VecGroup& VecGroup::operator=(const VecGroup& other4) {
  id = other4.id;
  dimension = other4.dimension;
  index_type = other4.index_type;
  __isset = other4.__isset;
  return *this;
}
void VecGroup::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "VecGroup(";
  out << "id=" << to_string(id);
  out << ", " << "dimension=" << to_string(dimension);
  out << ", " << "index_type="; (__isset.index_type ? (out << to_string(index_type)) : (out << "<null>"));
  out << ")";
}


VecTensor::~VecTensor() throw() {
}


void VecTensor::__set_uid(const std::string& val) {
  this->uid = val;
}

void VecTensor::__set_tensor(const std::vector<double> & val) {
  this->tensor = val;
}

void VecTensor::__set_attrib(const std::map<std::string, std::string> & val) {
  this->attrib = val;
__isset.attrib = true;
}
std::ostream& operator<<(std::ostream& out, const VecTensor& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t VecTensor::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_uid = false;
  bool isset_tensor = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->uid);
          isset_uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tensor.clear();
            uint32_t _size5;
            ::apache::thrift::protocol::TType _etype8;
            xfer += iprot->readListBegin(_etype8, _size5);
            this->tensor.resize(_size5);
            uint32_t _i9;
            for (_i9 = 0; _i9 < _size5; ++_i9)
            {
              xfer += iprot->readDouble(this->tensor[_i9]);
            }
            xfer += iprot->readListEnd();
          }
          isset_tensor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->attrib.clear();
            uint32_t _size10;
            ::apache::thrift::protocol::TType _ktype11;
            ::apache::thrift::protocol::TType _vtype12;
            xfer += iprot->readMapBegin(_ktype11, _vtype12, _size10);
            uint32_t _i14;
            for (_i14 = 0; _i14 < _size10; ++_i14)
            {
              std::string _key15;
              xfer += iprot->readString(_key15);
              std::string& _val16 = this->attrib[_key15];
              xfer += iprot->readString(_val16);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.attrib = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_uid)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tensor)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t VecTensor::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("VecTensor");

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tensor", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->tensor.size()));
    std::vector<double> ::const_iterator _iter17;
    for (_iter17 = this->tensor.begin(); _iter17 != this->tensor.end(); ++_iter17)
    {
      xfer += oprot->writeDouble((*_iter17));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.attrib) {
    xfer += oprot->writeFieldBegin("attrib", ::apache::thrift::protocol::T_MAP, 3);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->attrib.size()));
      std::map<std::string, std::string> ::const_iterator _iter18;
      for (_iter18 = this->attrib.begin(); _iter18 != this->attrib.end(); ++_iter18)
      {
        xfer += oprot->writeString(_iter18->first);
        xfer += oprot->writeString(_iter18->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(VecTensor &a, VecTensor &b) {
  using ::std::swap;
  swap(a.uid, b.uid);
  swap(a.tensor, b.tensor);
  swap(a.attrib, b.attrib);
  swap(a.__isset, b.__isset);
}

VecTensor::VecTensor(const VecTensor& other19) {
  uid = other19.uid;
  tensor = other19.tensor;
  attrib = other19.attrib;
  __isset = other19.__isset;
}
VecTensor& VecTensor::operator=(const VecTensor& other20) {
  uid = other20.uid;
  tensor = other20.tensor;
  attrib = other20.attrib;
  __isset = other20.__isset;
  return *this;
}
void VecTensor::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "VecTensor(";
  out << "uid=" << to_string(uid);
  out << ", " << "tensor=" << to_string(tensor);
  out << ", " << "attrib="; (__isset.attrib ? (out << to_string(attrib)) : (out << "<null>"));
  out << ")";
}


VecTensorList::~VecTensorList() throw() {
}


void VecTensorList::__set_tensor_list(const std::vector<VecTensor> & val) {
  this->tensor_list = val;
}
std::ostream& operator<<(std::ostream& out, const VecTensorList& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t VecTensorList::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tensor_list = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tensor_list.clear();
            uint32_t _size21;
            ::apache::thrift::protocol::TType _etype24;
            xfer += iprot->readListBegin(_etype24, _size21);
            this->tensor_list.resize(_size21);
            uint32_t _i25;
            for (_i25 = 0; _i25 < _size21; ++_i25)
            {
              xfer += this->tensor_list[_i25].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_tensor_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tensor_list)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t VecTensorList::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("VecTensorList");

  xfer += oprot->writeFieldBegin("tensor_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->tensor_list.size()));
    std::vector<VecTensor> ::const_iterator _iter26;
    for (_iter26 = this->tensor_list.begin(); _iter26 != this->tensor_list.end(); ++_iter26)
    {
      xfer += (*_iter26).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(VecTensorList &a, VecTensorList &b) {
  using ::std::swap;
  swap(a.tensor_list, b.tensor_list);
}

VecTensorList::VecTensorList(const VecTensorList& other27) {
  tensor_list = other27.tensor_list;
}
VecTensorList& VecTensorList::operator=(const VecTensorList& other28) {
  tensor_list = other28.tensor_list;
  return *this;
}
void VecTensorList::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "VecTensorList(";
  out << "tensor_list=" << to_string(tensor_list);
  out << ")";
}


VecBinaryTensor::~VecBinaryTensor() throw() {
}


void VecBinaryTensor::__set_uid(const std::string& val) {
  this->uid = val;
}

void VecBinaryTensor::__set_tensor(const std::string& val) {
  this->tensor = val;
}

void VecBinaryTensor::__set_attrib(const std::map<std::string, std::string> & val) {
  this->attrib = val;
__isset.attrib = true;
}
std::ostream& operator<<(std::ostream& out, const VecBinaryTensor& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t VecBinaryTensor::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_uid = false;
  bool isset_tensor = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->uid);
          isset_uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->tensor);
          isset_tensor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->attrib.clear();
            uint32_t _size29;
            ::apache::thrift::protocol::TType _ktype30;
            ::apache::thrift::protocol::TType _vtype31;
            xfer += iprot->readMapBegin(_ktype30, _vtype31, _size29);
            uint32_t _i33;
            for (_i33 = 0; _i33 < _size29; ++_i33)
            {
              std::string _key34;
              xfer += iprot->readString(_key34);
              std::string& _val35 = this->attrib[_key34];
              xfer += iprot->readString(_val35);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.attrib = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_uid)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tensor)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t VecBinaryTensor::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("VecBinaryTensor");

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tensor", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->tensor);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.attrib) {
    xfer += oprot->writeFieldBegin("attrib", ::apache::thrift::protocol::T_MAP, 3);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->attrib.size()));
      std::map<std::string, std::string> ::const_iterator _iter36;
      for (_iter36 = this->attrib.begin(); _iter36 != this->attrib.end(); ++_iter36)
      {
        xfer += oprot->writeString(_iter36->first);
        xfer += oprot->writeString(_iter36->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(VecBinaryTensor &a, VecBinaryTensor &b) {
  using ::std::swap;
  swap(a.uid, b.uid);
  swap(a.tensor, b.tensor);
  swap(a.attrib, b.attrib);
  swap(a.__isset, b.__isset);
}

VecBinaryTensor::VecBinaryTensor(const VecBinaryTensor& other37) {
  uid = other37.uid;
  tensor = other37.tensor;
  attrib = other37.attrib;
  __isset = other37.__isset;
}
VecBinaryTensor& VecBinaryTensor::operator=(const VecBinaryTensor& other38) {
  uid = other38.uid;
  tensor = other38.tensor;
  attrib = other38.attrib;
  __isset = other38.__isset;
  return *this;
}
void VecBinaryTensor::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "VecBinaryTensor(";
  out << "uid=" << to_string(uid);
  out << ", " << "tensor=" << to_string(tensor);
  out << ", " << "attrib="; (__isset.attrib ? (out << to_string(attrib)) : (out << "<null>"));
  out << ")";
}


VecBinaryTensorList::~VecBinaryTensorList() throw() {
}


void VecBinaryTensorList::__set_tensor_list(const std::vector<VecBinaryTensor> & val) {
  this->tensor_list = val;
}
std::ostream& operator<<(std::ostream& out, const VecBinaryTensorList& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t VecBinaryTensorList::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tensor_list = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tensor_list.clear();
            uint32_t _size39;
            ::apache::thrift::protocol::TType _etype42;
            xfer += iprot->readListBegin(_etype42, _size39);
            this->tensor_list.resize(_size39);
            uint32_t _i43;
            for (_i43 = 0; _i43 < _size39; ++_i43)
            {
              xfer += this->tensor_list[_i43].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_tensor_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tensor_list)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t VecBinaryTensorList::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("VecBinaryTensorList");

  xfer += oprot->writeFieldBegin("tensor_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->tensor_list.size()));
    std::vector<VecBinaryTensor> ::const_iterator _iter44;
    for (_iter44 = this->tensor_list.begin(); _iter44 != this->tensor_list.end(); ++_iter44)
    {
      xfer += (*_iter44).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(VecBinaryTensorList &a, VecBinaryTensorList &b) {
  using ::std::swap;
  swap(a.tensor_list, b.tensor_list);
}

VecBinaryTensorList::VecBinaryTensorList(const VecBinaryTensorList& other45) {
  tensor_list = other45.tensor_list;
}
VecBinaryTensorList& VecBinaryTensorList::operator=(const VecBinaryTensorList& other46) {
  tensor_list = other46.tensor_list;
  return *this;
}
void VecBinaryTensorList::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "VecBinaryTensorList(";
  out << "tensor_list=" << to_string(tensor_list);
  out << ")";
}


VecSearchResultItem::~VecSearchResultItem() throw() {
}


void VecSearchResultItem::__set_uid(const std::string& val) {
  this->uid = val;
}

void VecSearchResultItem::__set_distance(const double val) {
  this->distance = val;
__isset.distance = true;
}

void VecSearchResultItem::__set_attrib(const std::map<std::string, std::string> & val) {
  this->attrib = val;
__isset.attrib = true;
}
std::ostream& operator<<(std::ostream& out, const VecSearchResultItem& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t VecSearchResultItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_uid = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->uid);
          isset_uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->distance);
          this->__isset.distance = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->attrib.clear();
            uint32_t _size47;
            ::apache::thrift::protocol::TType _ktype48;
            ::apache::thrift::protocol::TType _vtype49;
            xfer += iprot->readMapBegin(_ktype48, _vtype49, _size47);
            uint32_t _i51;
            for (_i51 = 0; _i51 < _size47; ++_i51)
            {
              std::string _key52;
              xfer += iprot->readString(_key52);
              std::string& _val53 = this->attrib[_key52];
              xfer += iprot->readString(_val53);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.attrib = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_uid)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t VecSearchResultItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("VecSearchResultItem");

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->uid);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.distance) {
    xfer += oprot->writeFieldBegin("distance", ::apache::thrift::protocol::T_DOUBLE, 2);
    xfer += oprot->writeDouble(this->distance);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.attrib) {
    xfer += oprot->writeFieldBegin("attrib", ::apache::thrift::protocol::T_MAP, 3);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->attrib.size()));
      std::map<std::string, std::string> ::const_iterator _iter54;
      for (_iter54 = this->attrib.begin(); _iter54 != this->attrib.end(); ++_iter54)
      {
        xfer += oprot->writeString(_iter54->first);
        xfer += oprot->writeString(_iter54->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(VecSearchResultItem &a, VecSearchResultItem &b) {
  using ::std::swap;
  swap(a.uid, b.uid);
  swap(a.distance, b.distance);
  swap(a.attrib, b.attrib);
  swap(a.__isset, b.__isset);
}

VecSearchResultItem::VecSearchResultItem(const VecSearchResultItem& other55) {
  uid = other55.uid;
  distance = other55.distance;
  attrib = other55.attrib;
  __isset = other55.__isset;
}
VecSearchResultItem& VecSearchResultItem::operator=(const VecSearchResultItem& other56) {
  uid = other56.uid;
  distance = other56.distance;
  attrib = other56.attrib;
  __isset = other56.__isset;
  return *this;
}
void VecSearchResultItem::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "VecSearchResultItem(";
  out << "uid=" << to_string(uid);
  out << ", " << "distance="; (__isset.distance ? (out << to_string(distance)) : (out << "<null>"));
  out << ", " << "attrib="; (__isset.attrib ? (out << to_string(attrib)) : (out << "<null>"));
  out << ")";
}


VecSearchResult::~VecSearchResult() throw() {
}


void VecSearchResult::__set_result_list(const std::vector<VecSearchResultItem> & val) {
  this->result_list = val;
}
std::ostream& operator<<(std::ostream& out, const VecSearchResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t VecSearchResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->result_list.clear();
            uint32_t _size57;
            ::apache::thrift::protocol::TType _etype60;
            xfer += iprot->readListBegin(_etype60, _size57);
            this->result_list.resize(_size57);
            uint32_t _i61;
            for (_i61 = 0; _i61 < _size57; ++_i61)
            {
              xfer += this->result_list[_i61].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.result_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t VecSearchResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("VecSearchResult");

  xfer += oprot->writeFieldBegin("result_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->result_list.size()));
    std::vector<VecSearchResultItem> ::const_iterator _iter62;
    for (_iter62 = this->result_list.begin(); _iter62 != this->result_list.end(); ++_iter62)
    {
      xfer += (*_iter62).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(VecSearchResult &a, VecSearchResult &b) {
  using ::std::swap;
  swap(a.result_list, b.result_list);
  swap(a.__isset, b.__isset);
}

VecSearchResult::VecSearchResult(const VecSearchResult& other63) {
  result_list = other63.result_list;
  __isset = other63.__isset;
}
VecSearchResult& VecSearchResult::operator=(const VecSearchResult& other64) {
  result_list = other64.result_list;
  __isset = other64.__isset;
  return *this;
}
void VecSearchResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "VecSearchResult(";
  out << "result_list=" << to_string(result_list);
  out << ")";
}


VecSearchResultList::~VecSearchResultList() throw() {
}


void VecSearchResultList::__set_result_list(const std::vector<VecSearchResult> & val) {
  this->result_list = val;
}
std::ostream& operator<<(std::ostream& out, const VecSearchResultList& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t VecSearchResultList::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->result_list.clear();
            uint32_t _size65;
            ::apache::thrift::protocol::TType _etype68;
            xfer += iprot->readListBegin(_etype68, _size65);
            this->result_list.resize(_size65);
            uint32_t _i69;
            for (_i69 = 0; _i69 < _size65; ++_i69)
            {
              xfer += this->result_list[_i69].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.result_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t VecSearchResultList::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("VecSearchResultList");

  xfer += oprot->writeFieldBegin("result_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->result_list.size()));
    std::vector<VecSearchResult> ::const_iterator _iter70;
    for (_iter70 = this->result_list.begin(); _iter70 != this->result_list.end(); ++_iter70)
    {
      xfer += (*_iter70).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(VecSearchResultList &a, VecSearchResultList &b) {
  using ::std::swap;
  swap(a.result_list, b.result_list);
  swap(a.__isset, b.__isset);
}

VecSearchResultList::VecSearchResultList(const VecSearchResultList& other71) {
  result_list = other71.result_list;
  __isset = other71.__isset;
}
VecSearchResultList& VecSearchResultList::operator=(const VecSearchResultList& other72) {
  result_list = other72.result_list;
  __isset = other72.__isset;
  return *this;
}
void VecSearchResultList::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "VecSearchResultList(";
  out << "result_list=" << to_string(result_list);
  out << ")";
}


VecDateTime::~VecDateTime() throw() {
}


void VecDateTime::__set_year(const int32_t val) {
  this->year = val;
}

void VecDateTime::__set_month(const int32_t val) {
  this->month = val;
}

void VecDateTime::__set_day(const int32_t val) {
  this->day = val;
}

void VecDateTime::__set_hour(const int32_t val) {
  this->hour = val;
}

void VecDateTime::__set_minute(const int32_t val) {
  this->minute = val;
}

void VecDateTime::__set_second(const int32_t val) {
  this->second = val;
}
std::ostream& operator<<(std::ostream& out, const VecDateTime& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t VecDateTime::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_year = false;
  bool isset_month = false;
  bool isset_day = false;
  bool isset_hour = false;
  bool isset_minute = false;
  bool isset_second = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->year);
          isset_year = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->month);
          isset_month = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->day);
          isset_day = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->hour);
          isset_hour = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->minute);
          isset_minute = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->second);
          isset_second = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_year)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_month)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_day)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_hour)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_minute)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_second)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t VecDateTime::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("VecDateTime");

  xfer += oprot->writeFieldBegin("year", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->year);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("month", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->month);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("day", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->day);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hour", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->hour);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minute", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->minute);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("second", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->second);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(VecDateTime &a, VecDateTime &b) {
  using ::std::swap;
  swap(a.year, b.year);
  swap(a.month, b.month);
  swap(a.day, b.day);
  swap(a.hour, b.hour);
  swap(a.minute, b.minute);
  swap(a.second, b.second);
}

VecDateTime::VecDateTime(const VecDateTime& other73) {
  year = other73.year;
  month = other73.month;
  day = other73.day;
  hour = other73.hour;
  minute = other73.minute;
  second = other73.second;
}
VecDateTime& VecDateTime::operator=(const VecDateTime& other74) {
  year = other74.year;
  month = other74.month;
  day = other74.day;
  hour = other74.hour;
  minute = other74.minute;
  second = other74.second;
  return *this;
}
void VecDateTime::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "VecDateTime(";
  out << "year=" << to_string(year);
  out << ", " << "month=" << to_string(month);
  out << ", " << "day=" << to_string(day);
  out << ", " << "hour=" << to_string(hour);
  out << ", " << "minute=" << to_string(minute);
  out << ", " << "second=" << to_string(second);
  out << ")";
}


VecTimeRange::~VecTimeRange() throw() {
}


void VecTimeRange::__set_time_begin(const VecDateTime& val) {
  this->time_begin = val;
}

void VecTimeRange::__set_begine_closed(const bool val) {
  this->begine_closed = val;
}

void VecTimeRange::__set_time_end(const VecDateTime& val) {
  this->time_end = val;
}

void VecTimeRange::__set_end_closed(const bool val) {
  this->end_closed = val;
}
std::ostream& operator<<(std::ostream& out, const VecTimeRange& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t VecTimeRange::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_time_begin = false;
  bool isset_begine_closed = false;
  bool isset_time_end = false;
  bool isset_end_closed = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->time_begin.read(iprot);
          isset_time_begin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->begine_closed);
          isset_begine_closed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->time_end.read(iprot);
          isset_time_end = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->end_closed);
          isset_end_closed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_time_begin)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_begine_closed)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_time_end)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_end_closed)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t VecTimeRange::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("VecTimeRange");

  xfer += oprot->writeFieldBegin("time_begin", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->time_begin.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("begine_closed", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->begine_closed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("time_end", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->time_end.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("end_closed", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->end_closed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(VecTimeRange &a, VecTimeRange &b) {
  using ::std::swap;
  swap(a.time_begin, b.time_begin);
  swap(a.begine_closed, b.begine_closed);
  swap(a.time_end, b.time_end);
  swap(a.end_closed, b.end_closed);
}

VecTimeRange::VecTimeRange(const VecTimeRange& other75) {
  time_begin = other75.time_begin;
  begine_closed = other75.begine_closed;
  time_end = other75.time_end;
  end_closed = other75.end_closed;
}
VecTimeRange& VecTimeRange::operator=(const VecTimeRange& other76) {
  time_begin = other76.time_begin;
  begine_closed = other76.begine_closed;
  time_end = other76.time_end;
  end_closed = other76.end_closed;
  return *this;
}
void VecTimeRange::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "VecTimeRange(";
  out << "time_begin=" << to_string(time_begin);
  out << ", " << "begine_closed=" << to_string(begine_closed);
  out << ", " << "time_end=" << to_string(time_end);
  out << ", " << "end_closed=" << to_string(end_closed);
  out << ")";
}


VecSearchFilter::~VecSearchFilter() throw() {
}


void VecSearchFilter::__set_attrib_filter(const std::map<std::string, std::string> & val) {
  this->attrib_filter = val;
__isset.attrib_filter = true;
}

void VecSearchFilter::__set_time_ranges(const std::vector<VecTimeRange> & val) {
  this->time_ranges = val;
__isset.time_ranges = true;
}

void VecSearchFilter::__set_return_attribs(const std::vector<std::string> & val) {
  this->return_attribs = val;
__isset.return_attribs = true;
}
std::ostream& operator<<(std::ostream& out, const VecSearchFilter& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t VecSearchFilter::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->attrib_filter.clear();
            uint32_t _size77;
            ::apache::thrift::protocol::TType _ktype78;
            ::apache::thrift::protocol::TType _vtype79;
            xfer += iprot->readMapBegin(_ktype78, _vtype79, _size77);
            uint32_t _i81;
            for (_i81 = 0; _i81 < _size77; ++_i81)
            {
              std::string _key82;
              xfer += iprot->readString(_key82);
              std::string& _val83 = this->attrib_filter[_key82];
              xfer += iprot->readString(_val83);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.attrib_filter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->time_ranges.clear();
            uint32_t _size84;
            ::apache::thrift::protocol::TType _etype87;
            xfer += iprot->readListBegin(_etype87, _size84);
            this->time_ranges.resize(_size84);
            uint32_t _i88;
            for (_i88 = 0; _i88 < _size84; ++_i88)
            {
              xfer += this->time_ranges[_i88].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.time_ranges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->return_attribs.clear();
            uint32_t _size89;
            ::apache::thrift::protocol::TType _etype92;
            xfer += iprot->readListBegin(_etype92, _size89);
            this->return_attribs.resize(_size89);
            uint32_t _i93;
            for (_i93 = 0; _i93 < _size89; ++_i93)
            {
              xfer += iprot->readString(this->return_attribs[_i93]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.return_attribs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t VecSearchFilter::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("VecSearchFilter");

  if (this->__isset.attrib_filter) {
    xfer += oprot->writeFieldBegin("attrib_filter", ::apache::thrift::protocol::T_MAP, 1);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->attrib_filter.size()));
      std::map<std::string, std::string> ::const_iterator _iter94;
      for (_iter94 = this->attrib_filter.begin(); _iter94 != this->attrib_filter.end(); ++_iter94)
      {
        xfer += oprot->writeString(_iter94->first);
        xfer += oprot->writeString(_iter94->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.time_ranges) {
    xfer += oprot->writeFieldBegin("time_ranges", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->time_ranges.size()));
      std::vector<VecTimeRange> ::const_iterator _iter95;
      for (_iter95 = this->time_ranges.begin(); _iter95 != this->time_ranges.end(); ++_iter95)
      {
        xfer += (*_iter95).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.return_attribs) {
    xfer += oprot->writeFieldBegin("return_attribs", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->return_attribs.size()));
      std::vector<std::string> ::const_iterator _iter96;
      for (_iter96 = this->return_attribs.begin(); _iter96 != this->return_attribs.end(); ++_iter96)
      {
        xfer += oprot->writeString((*_iter96));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(VecSearchFilter &a, VecSearchFilter &b) {
  using ::std::swap;
  swap(a.attrib_filter, b.attrib_filter);
  swap(a.time_ranges, b.time_ranges);
  swap(a.return_attribs, b.return_attribs);
  swap(a.__isset, b.__isset);
}

VecSearchFilter::VecSearchFilter(const VecSearchFilter& other97) {
  attrib_filter = other97.attrib_filter;
  time_ranges = other97.time_ranges;
  return_attribs = other97.return_attribs;
  __isset = other97.__isset;
}
VecSearchFilter& VecSearchFilter::operator=(const VecSearchFilter& other98) {
  attrib_filter = other98.attrib_filter;
  time_ranges = other98.time_ranges;
  return_attribs = other98.return_attribs;
  __isset = other98.__isset;
  return *this;
}
void VecSearchFilter::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "VecSearchFilter(";
  out << "attrib_filter="; (__isset.attrib_filter ? (out << to_string(attrib_filter)) : (out << "<null>"));
  out << ", " << "time_ranges="; (__isset.time_ranges ? (out << to_string(time_ranges)) : (out << "<null>"));
  out << ", " << "return_attribs="; (__isset.return_attribs ? (out << to_string(return_attribs)) : (out << "<null>"));
  out << ")";
}

} // namespace
