/**
 * Autogenerated by Thrift Compiler (0.12.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "VectorService_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>



int _kVecErrCodeValues[] = {
  VecErrCode::SUCCESS,
  VecErrCode::ILLEGAL_ARGUMENT,
  VecErrCode::GROUP_NOT_EXISTS,
  VecErrCode::ILLEGAL_TIME_RANGE,
  VecErrCode::ILLEGAL_VECTOR_DIMENSION,
  VecErrCode::OUT_OF_MEMORY
};
const char* _kVecErrCodeNames[] = {
  "SUCCESS",
  "ILLEGAL_ARGUMENT",
  "GROUP_NOT_EXISTS",
  "ILLEGAL_TIME_RANGE",
  "ILLEGAL_VECTOR_DIMENSION",
  "OUT_OF_MEMORY"
};
const std::map<int, const char*> _VecErrCode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kVecErrCodeValues, _kVecErrCodeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const VecErrCode::type& val) {
  std::map<int, const char*>::const_iterator it = _VecErrCode_VALUES_TO_NAMES.find(val);
  if (it != _VecErrCode_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}


VecException::~VecException() throw() {
}


void VecException::__set_code(const VecErrCode::type val) {
  this->code = val;
}

void VecException::__set_reason(const std::string& val) {
  this->reason = val;
}
std::ostream& operator<<(std::ostream& out, const VecException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t VecException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->code = (VecErrCode::type)ecast0;
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->reason);
          this->__isset.reason = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t VecException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("VecException");

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("reason", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->reason);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(VecException &a, VecException &b) {
  using ::std::swap;
  swap(a.code, b.code);
  swap(a.reason, b.reason);
  swap(a.__isset, b.__isset);
}

VecException::VecException(const VecException& other1) : TException() {
  code = other1.code;
  reason = other1.reason;
  __isset = other1.__isset;
}
VecException& VecException::operator=(const VecException& other2) {
  code = other2.code;
  reason = other2.reason;
  __isset = other2.__isset;
  return *this;
}
void VecException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "VecException(";
  out << "code=" << to_string(code);
  out << ", " << "reason=" << to_string(reason);
  out << ")";
}

const char* VecException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: VecException";
  }
}


VecGroup::~VecGroup() throw() {
}


void VecGroup::__set_id(const std::string& val) {
  this->id = val;
}

void VecGroup::__set_dimension(const int32_t val) {
  this->dimension = val;
}

void VecGroup::__set_index_type(const int32_t val) {
  this->index_type = val;
}
std::ostream& operator<<(std::ostream& out, const VecGroup& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t VecGroup::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->dimension);
          this->__isset.dimension = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->index_type);
          this->__isset.index_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t VecGroup::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("VecGroup");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dimension", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->dimension);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("index_type", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->index_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(VecGroup &a, VecGroup &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.dimension, b.dimension);
  swap(a.index_type, b.index_type);
  swap(a.__isset, b.__isset);
}

VecGroup::VecGroup(const VecGroup& other3) {
  id = other3.id;
  dimension = other3.dimension;
  index_type = other3.index_type;
  __isset = other3.__isset;
}
VecGroup& VecGroup::operator=(const VecGroup& other4) {
  id = other4.id;
  dimension = other4.dimension;
  index_type = other4.index_type;
  __isset = other4.__isset;
  return *this;
}
void VecGroup::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "VecGroup(";
  out << "id=" << to_string(id);
  out << ", " << "dimension=" << to_string(dimension);
  out << ", " << "index_type=" << to_string(index_type);
  out << ")";
}


VecTensor::~VecTensor() throw() {
}


void VecTensor::__set_uid(const std::string& val) {
  this->uid = val;
}

void VecTensor::__set_tensor(const std::vector<double> & val) {
  this->tensor = val;
}
std::ostream& operator<<(std::ostream& out, const VecTensor& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t VecTensor::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tensor.clear();
            uint32_t _size5;
            ::apache::thrift::protocol::TType _etype8;
            xfer += iprot->readListBegin(_etype8, _size5);
            this->tensor.resize(_size5);
            uint32_t _i9;
            for (_i9 = 0; _i9 < _size5; ++_i9)
            {
              xfer += iprot->readDouble(this->tensor[_i9]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.tensor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t VecTensor::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("VecTensor");

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tensor", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->tensor.size()));
    std::vector<double> ::const_iterator _iter10;
    for (_iter10 = this->tensor.begin(); _iter10 != this->tensor.end(); ++_iter10)
    {
      xfer += oprot->writeDouble((*_iter10));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(VecTensor &a, VecTensor &b) {
  using ::std::swap;
  swap(a.uid, b.uid);
  swap(a.tensor, b.tensor);
  swap(a.__isset, b.__isset);
}

VecTensor::VecTensor(const VecTensor& other11) {
  uid = other11.uid;
  tensor = other11.tensor;
  __isset = other11.__isset;
}
VecTensor& VecTensor::operator=(const VecTensor& other12) {
  uid = other12.uid;
  tensor = other12.tensor;
  __isset = other12.__isset;
  return *this;
}
void VecTensor::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "VecTensor(";
  out << "uid=" << to_string(uid);
  out << ", " << "tensor=" << to_string(tensor);
  out << ")";
}


VecTensorList::~VecTensorList() throw() {
}


void VecTensorList::__set_tensor_list(const std::vector<VecTensor> & val) {
  this->tensor_list = val;
}
std::ostream& operator<<(std::ostream& out, const VecTensorList& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t VecTensorList::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tensor_list.clear();
            uint32_t _size13;
            ::apache::thrift::protocol::TType _etype16;
            xfer += iprot->readListBegin(_etype16, _size13);
            this->tensor_list.resize(_size13);
            uint32_t _i17;
            for (_i17 = 0; _i17 < _size13; ++_i17)
            {
              xfer += this->tensor_list[_i17].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.tensor_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t VecTensorList::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("VecTensorList");

  xfer += oprot->writeFieldBegin("tensor_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->tensor_list.size()));
    std::vector<VecTensor> ::const_iterator _iter18;
    for (_iter18 = this->tensor_list.begin(); _iter18 != this->tensor_list.end(); ++_iter18)
    {
      xfer += (*_iter18).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(VecTensorList &a, VecTensorList &b) {
  using ::std::swap;
  swap(a.tensor_list, b.tensor_list);
  swap(a.__isset, b.__isset);
}

VecTensorList::VecTensorList(const VecTensorList& other19) {
  tensor_list = other19.tensor_list;
  __isset = other19.__isset;
}
VecTensorList& VecTensorList::operator=(const VecTensorList& other20) {
  tensor_list = other20.tensor_list;
  __isset = other20.__isset;
  return *this;
}
void VecTensorList::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "VecTensorList(";
  out << "tensor_list=" << to_string(tensor_list);
  out << ")";
}


VecSearchResult::~VecSearchResult() throw() {
}


void VecSearchResult::__set_id_list(const std::vector<std::string> & val) {
  this->id_list = val;
}

void VecSearchResult::__set_distance_list(const std::vector<double> & val) {
  this->distance_list = val;
}
std::ostream& operator<<(std::ostream& out, const VecSearchResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t VecSearchResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->id_list.clear();
            uint32_t _size21;
            ::apache::thrift::protocol::TType _etype24;
            xfer += iprot->readListBegin(_etype24, _size21);
            this->id_list.resize(_size21);
            uint32_t _i25;
            for (_i25 = 0; _i25 < _size21; ++_i25)
            {
              xfer += iprot->readString(this->id_list[_i25]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.id_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->distance_list.clear();
            uint32_t _size26;
            ::apache::thrift::protocol::TType _etype29;
            xfer += iprot->readListBegin(_etype29, _size26);
            this->distance_list.resize(_size26);
            uint32_t _i30;
            for (_i30 = 0; _i30 < _size26; ++_i30)
            {
              xfer += iprot->readDouble(this->distance_list[_i30]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.distance_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t VecSearchResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("VecSearchResult");

  xfer += oprot->writeFieldBegin("id_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->id_list.size()));
    std::vector<std::string> ::const_iterator _iter31;
    for (_iter31 = this->id_list.begin(); _iter31 != this->id_list.end(); ++_iter31)
    {
      xfer += oprot->writeString((*_iter31));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("distance_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->distance_list.size()));
    std::vector<double> ::const_iterator _iter32;
    for (_iter32 = this->distance_list.begin(); _iter32 != this->distance_list.end(); ++_iter32)
    {
      xfer += oprot->writeDouble((*_iter32));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(VecSearchResult &a, VecSearchResult &b) {
  using ::std::swap;
  swap(a.id_list, b.id_list);
  swap(a.distance_list, b.distance_list);
  swap(a.__isset, b.__isset);
}

VecSearchResult::VecSearchResult(const VecSearchResult& other33) {
  id_list = other33.id_list;
  distance_list = other33.distance_list;
  __isset = other33.__isset;
}
VecSearchResult& VecSearchResult::operator=(const VecSearchResult& other34) {
  id_list = other34.id_list;
  distance_list = other34.distance_list;
  __isset = other34.__isset;
  return *this;
}
void VecSearchResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "VecSearchResult(";
  out << "id_list=" << to_string(id_list);
  out << ", " << "distance_list=" << to_string(distance_list);
  out << ")";
}


VecSearchResultList::~VecSearchResultList() throw() {
}


void VecSearchResultList::__set_result_list(const std::vector<VecSearchResult> & val) {
  this->result_list = val;
}
std::ostream& operator<<(std::ostream& out, const VecSearchResultList& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t VecSearchResultList::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->result_list.clear();
            uint32_t _size35;
            ::apache::thrift::protocol::TType _etype38;
            xfer += iprot->readListBegin(_etype38, _size35);
            this->result_list.resize(_size35);
            uint32_t _i39;
            for (_i39 = 0; _i39 < _size35; ++_i39)
            {
              xfer += this->result_list[_i39].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.result_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t VecSearchResultList::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("VecSearchResultList");

  xfer += oprot->writeFieldBegin("result_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->result_list.size()));
    std::vector<VecSearchResult> ::const_iterator _iter40;
    for (_iter40 = this->result_list.begin(); _iter40 != this->result_list.end(); ++_iter40)
    {
      xfer += (*_iter40).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(VecSearchResultList &a, VecSearchResultList &b) {
  using ::std::swap;
  swap(a.result_list, b.result_list);
  swap(a.__isset, b.__isset);
}

VecSearchResultList::VecSearchResultList(const VecSearchResultList& other41) {
  result_list = other41.result_list;
  __isset = other41.__isset;
}
VecSearchResultList& VecSearchResultList::operator=(const VecSearchResultList& other42) {
  result_list = other42.result_list;
  __isset = other42.__isset;
  return *this;
}
void VecSearchResultList::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "VecSearchResultList(";
  out << "result_list=" << to_string(result_list);
  out << ")";
}


VecDateTime::~VecDateTime() throw() {
}


void VecDateTime::__set_year(const int32_t val) {
  this->year = val;
}

void VecDateTime::__set_month(const int32_t val) {
  this->month = val;
}

void VecDateTime::__set_day(const int32_t val) {
  this->day = val;
}

void VecDateTime::__set_hour(const int32_t val) {
  this->hour = val;
}

void VecDateTime::__set_minute(const int32_t val) {
  this->minute = val;
}

void VecDateTime::__set_second(const int32_t val) {
  this->second = val;
}
std::ostream& operator<<(std::ostream& out, const VecDateTime& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t VecDateTime::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->year);
          this->__isset.year = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->month);
          this->__isset.month = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->day);
          this->__isset.day = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->hour);
          this->__isset.hour = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->minute);
          this->__isset.minute = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->second);
          this->__isset.second = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t VecDateTime::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("VecDateTime");

  xfer += oprot->writeFieldBegin("year", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->year);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("month", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->month);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("day", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->day);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hour", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->hour);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minute", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->minute);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("second", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->second);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(VecDateTime &a, VecDateTime &b) {
  using ::std::swap;
  swap(a.year, b.year);
  swap(a.month, b.month);
  swap(a.day, b.day);
  swap(a.hour, b.hour);
  swap(a.minute, b.minute);
  swap(a.second, b.second);
  swap(a.__isset, b.__isset);
}

VecDateTime::VecDateTime(const VecDateTime& other43) {
  year = other43.year;
  month = other43.month;
  day = other43.day;
  hour = other43.hour;
  minute = other43.minute;
  second = other43.second;
  __isset = other43.__isset;
}
VecDateTime& VecDateTime::operator=(const VecDateTime& other44) {
  year = other44.year;
  month = other44.month;
  day = other44.day;
  hour = other44.hour;
  minute = other44.minute;
  second = other44.second;
  __isset = other44.__isset;
  return *this;
}
void VecDateTime::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "VecDateTime(";
  out << "year=" << to_string(year);
  out << ", " << "month=" << to_string(month);
  out << ", " << "day=" << to_string(day);
  out << ", " << "hour=" << to_string(hour);
  out << ", " << "minute=" << to_string(minute);
  out << ", " << "second=" << to_string(second);
  out << ")";
}


VecTimeRange::~VecTimeRange() throw() {
}


void VecTimeRange::__set_time_begin(const VecDateTime& val) {
  this->time_begin = val;
}

void VecTimeRange::__set_begine_closed(const bool val) {
  this->begine_closed = val;
}

void VecTimeRange::__set_time_end(const VecDateTime& val) {
  this->time_end = val;
}

void VecTimeRange::__set_end_closed(const bool val) {
  this->end_closed = val;
}
std::ostream& operator<<(std::ostream& out, const VecTimeRange& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t VecTimeRange::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->time_begin.read(iprot);
          this->__isset.time_begin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->begine_closed);
          this->__isset.begine_closed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->time_end.read(iprot);
          this->__isset.time_end = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->end_closed);
          this->__isset.end_closed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t VecTimeRange::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("VecTimeRange");

  xfer += oprot->writeFieldBegin("time_begin", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->time_begin.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("begine_closed", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->begine_closed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("time_end", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->time_end.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("end_closed", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->end_closed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(VecTimeRange &a, VecTimeRange &b) {
  using ::std::swap;
  swap(a.time_begin, b.time_begin);
  swap(a.begine_closed, b.begine_closed);
  swap(a.time_end, b.time_end);
  swap(a.end_closed, b.end_closed);
  swap(a.__isset, b.__isset);
}

VecTimeRange::VecTimeRange(const VecTimeRange& other45) {
  time_begin = other45.time_begin;
  begine_closed = other45.begine_closed;
  time_end = other45.time_end;
  end_closed = other45.end_closed;
  __isset = other45.__isset;
}
VecTimeRange& VecTimeRange::operator=(const VecTimeRange& other46) {
  time_begin = other46.time_begin;
  begine_closed = other46.begine_closed;
  time_end = other46.time_end;
  end_closed = other46.end_closed;
  __isset = other46.__isset;
  return *this;
}
void VecTimeRange::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "VecTimeRange(";
  out << "time_begin=" << to_string(time_begin);
  out << ", " << "begine_closed=" << to_string(begine_closed);
  out << ", " << "time_end=" << to_string(time_end);
  out << ", " << "end_closed=" << to_string(end_closed);
  out << ")";
}


VecTimeRangeList::~VecTimeRangeList() throw() {
}


void VecTimeRangeList::__set_range_list(const std::vector<VecTimeRange> & val) {
  this->range_list = val;
}
std::ostream& operator<<(std::ostream& out, const VecTimeRangeList& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t VecTimeRangeList::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->range_list.clear();
            uint32_t _size47;
            ::apache::thrift::protocol::TType _etype50;
            xfer += iprot->readListBegin(_etype50, _size47);
            this->range_list.resize(_size47);
            uint32_t _i51;
            for (_i51 = 0; _i51 < _size47; ++_i51)
            {
              xfer += this->range_list[_i51].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.range_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t VecTimeRangeList::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("VecTimeRangeList");

  xfer += oprot->writeFieldBegin("range_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->range_list.size()));
    std::vector<VecTimeRange> ::const_iterator _iter52;
    for (_iter52 = this->range_list.begin(); _iter52 != this->range_list.end(); ++_iter52)
    {
      xfer += (*_iter52).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(VecTimeRangeList &a, VecTimeRangeList &b) {
  using ::std::swap;
  swap(a.range_list, b.range_list);
  swap(a.__isset, b.__isset);
}

VecTimeRangeList::VecTimeRangeList(const VecTimeRangeList& other53) {
  range_list = other53.range_list;
  __isset = other53.__isset;
}
VecTimeRangeList& VecTimeRangeList::operator=(const VecTimeRangeList& other54) {
  range_list = other54.range_list;
  __isset = other54.__isset;
  return *this;
}
void VecTimeRangeList::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "VecTimeRangeList(";
  out << "range_list=" << to_string(range_list);
  out << ")";
}


