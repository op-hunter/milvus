/**
 * Autogenerated by Thrift Compiler (0.12.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "VectorService_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>



int _kVecErrCodeValues[] = {
  VecErrCode::SUCCESS,
  VecErrCode::ILLEGAL_ARGUMENT,
  VecErrCode::GROUP_NOT_EXISTS,
  VecErrCode::ILLEGAL_TIME_RANGE,
  VecErrCode::ILLEGAL_VECTOR_DIMENSION,
  VecErrCode::OUT_OF_MEMORY
};
const char* _kVecErrCodeNames[] = {
  "SUCCESS",
  "ILLEGAL_ARGUMENT",
  "GROUP_NOT_EXISTS",
  "ILLEGAL_TIME_RANGE",
  "ILLEGAL_VECTOR_DIMENSION",
  "OUT_OF_MEMORY"
};
const std::map<int, const char*> _VecErrCode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kVecErrCodeValues, _kVecErrCodeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const VecErrCode::type& val) {
  std::map<int, const char*>::const_iterator it = _VecErrCode_VALUES_TO_NAMES.find(val);
  if (it != _VecErrCode_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}


VecException::~VecException() throw() {
}


void VecException::__set_code(const VecErrCode::type val) {
  this->code = val;
}

void VecException::__set_reason(const std::string& val) {
  this->reason = val;
}
std::ostream& operator<<(std::ostream& out, const VecException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t VecException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->code = (VecErrCode::type)ecast0;
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->reason);
          this->__isset.reason = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t VecException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("VecException");

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("reason", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->reason);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(VecException &a, VecException &b) {
  using ::std::swap;
  swap(a.code, b.code);
  swap(a.reason, b.reason);
  swap(a.__isset, b.__isset);
}

VecException::VecException(const VecException& other1) : TException() {
  code = other1.code;
  reason = other1.reason;
  __isset = other1.__isset;
}
VecException& VecException::operator=(const VecException& other2) {
  code = other2.code;
  reason = other2.reason;
  __isset = other2.__isset;
  return *this;
}
void VecException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "VecException(";
  out << "code=" << to_string(code);
  out << ", " << "reason=" << to_string(reason);
  out << ")";
}

const char* VecException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: VecException";
  }
}


VecGroup::~VecGroup() throw() {
}


void VecGroup::__set_id(const std::string& val) {
  this->id = val;
}

void VecGroup::__set_dimension(const int32_t val) {
  this->dimension = val;
}

void VecGroup::__set_index_type(const int32_t val) {
  this->index_type = val;
}
std::ostream& operator<<(std::ostream& out, const VecGroup& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t VecGroup::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->dimension);
          this->__isset.dimension = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->index_type);
          this->__isset.index_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t VecGroup::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("VecGroup");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dimension", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->dimension);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("index_type", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->index_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(VecGroup &a, VecGroup &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.dimension, b.dimension);
  swap(a.index_type, b.index_type);
  swap(a.__isset, b.__isset);
}

VecGroup::VecGroup(const VecGroup& other3) {
  id = other3.id;
  dimension = other3.dimension;
  index_type = other3.index_type;
  __isset = other3.__isset;
}
VecGroup& VecGroup::operator=(const VecGroup& other4) {
  id = other4.id;
  dimension = other4.dimension;
  index_type = other4.index_type;
  __isset = other4.__isset;
  return *this;
}
void VecGroup::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "VecGroup(";
  out << "id=" << to_string(id);
  out << ", " << "dimension=" << to_string(dimension);
  out << ", " << "index_type=" << to_string(index_type);
  out << ")";
}


VecTensor::~VecTensor() throw() {
}


void VecTensor::__set_uid(const std::string& val) {
  this->uid = val;
}

void VecTensor::__set_tensor(const std::vector<double> & val) {
  this->tensor = val;
}
std::ostream& operator<<(std::ostream& out, const VecTensor& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t VecTensor::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tensor.clear();
            uint32_t _size5;
            ::apache::thrift::protocol::TType _etype8;
            xfer += iprot->readListBegin(_etype8, _size5);
            this->tensor.resize(_size5);
            uint32_t _i9;
            for (_i9 = 0; _i9 < _size5; ++_i9)
            {
              xfer += iprot->readDouble(this->tensor[_i9]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.tensor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t VecTensor::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("VecTensor");

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tensor", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->tensor.size()));
    std::vector<double> ::const_iterator _iter10;
    for (_iter10 = this->tensor.begin(); _iter10 != this->tensor.end(); ++_iter10)
    {
      xfer += oprot->writeDouble((*_iter10));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(VecTensor &a, VecTensor &b) {
  using ::std::swap;
  swap(a.uid, b.uid);
  swap(a.tensor, b.tensor);
  swap(a.__isset, b.__isset);
}

VecTensor::VecTensor(const VecTensor& other11) {
  uid = other11.uid;
  tensor = other11.tensor;
  __isset = other11.__isset;
}
VecTensor& VecTensor::operator=(const VecTensor& other12) {
  uid = other12.uid;
  tensor = other12.tensor;
  __isset = other12.__isset;
  return *this;
}
void VecTensor::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "VecTensor(";
  out << "uid=" << to_string(uid);
  out << ", " << "tensor=" << to_string(tensor);
  out << ")";
}


VecTensorList::~VecTensorList() throw() {
}


void VecTensorList::__set_tensor_list(const std::vector<VecTensor> & val) {
  this->tensor_list = val;
}
std::ostream& operator<<(std::ostream& out, const VecTensorList& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t VecTensorList::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tensor_list.clear();
            uint32_t _size13;
            ::apache::thrift::protocol::TType _etype16;
            xfer += iprot->readListBegin(_etype16, _size13);
            this->tensor_list.resize(_size13);
            uint32_t _i17;
            for (_i17 = 0; _i17 < _size13; ++_i17)
            {
              xfer += this->tensor_list[_i17].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.tensor_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t VecTensorList::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("VecTensorList");

  xfer += oprot->writeFieldBegin("tensor_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->tensor_list.size()));
    std::vector<VecTensor> ::const_iterator _iter18;
    for (_iter18 = this->tensor_list.begin(); _iter18 != this->tensor_list.end(); ++_iter18)
    {
      xfer += (*_iter18).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(VecTensorList &a, VecTensorList &b) {
  using ::std::swap;
  swap(a.tensor_list, b.tensor_list);
  swap(a.__isset, b.__isset);
}

VecTensorList::VecTensorList(const VecTensorList& other19) {
  tensor_list = other19.tensor_list;
  __isset = other19.__isset;
}
VecTensorList& VecTensorList::operator=(const VecTensorList& other20) {
  tensor_list = other20.tensor_list;
  __isset = other20.__isset;
  return *this;
}
void VecTensorList::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "VecTensorList(";
  out << "tensor_list=" << to_string(tensor_list);
  out << ")";
}


VecBinaryTensor::~VecBinaryTensor() throw() {
}


void VecBinaryTensor::__set_uid(const std::string& val) {
  this->uid = val;
}

void VecBinaryTensor::__set_tensor(const std::string& val) {
  this->tensor = val;
}
std::ostream& operator<<(std::ostream& out, const VecBinaryTensor& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t VecBinaryTensor::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->tensor);
          this->__isset.tensor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t VecBinaryTensor::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("VecBinaryTensor");

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tensor", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->tensor);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(VecBinaryTensor &a, VecBinaryTensor &b) {
  using ::std::swap;
  swap(a.uid, b.uid);
  swap(a.tensor, b.tensor);
  swap(a.__isset, b.__isset);
}

VecBinaryTensor::VecBinaryTensor(const VecBinaryTensor& other21) {
  uid = other21.uid;
  tensor = other21.tensor;
  __isset = other21.__isset;
}
VecBinaryTensor& VecBinaryTensor::operator=(const VecBinaryTensor& other22) {
  uid = other22.uid;
  tensor = other22.tensor;
  __isset = other22.__isset;
  return *this;
}
void VecBinaryTensor::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "VecBinaryTensor(";
  out << "uid=" << to_string(uid);
  out << ", " << "tensor=" << to_string(tensor);
  out << ")";
}


VecBinaryTensorList::~VecBinaryTensorList() throw() {
}


void VecBinaryTensorList::__set_tensor_list(const std::vector<VecBinaryTensor> & val) {
  this->tensor_list = val;
}
std::ostream& operator<<(std::ostream& out, const VecBinaryTensorList& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t VecBinaryTensorList::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tensor_list.clear();
            uint32_t _size23;
            ::apache::thrift::protocol::TType _etype26;
            xfer += iprot->readListBegin(_etype26, _size23);
            this->tensor_list.resize(_size23);
            uint32_t _i27;
            for (_i27 = 0; _i27 < _size23; ++_i27)
            {
              xfer += this->tensor_list[_i27].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.tensor_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t VecBinaryTensorList::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("VecBinaryTensorList");

  xfer += oprot->writeFieldBegin("tensor_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->tensor_list.size()));
    std::vector<VecBinaryTensor> ::const_iterator _iter28;
    for (_iter28 = this->tensor_list.begin(); _iter28 != this->tensor_list.end(); ++_iter28)
    {
      xfer += (*_iter28).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(VecBinaryTensorList &a, VecBinaryTensorList &b) {
  using ::std::swap;
  swap(a.tensor_list, b.tensor_list);
  swap(a.__isset, b.__isset);
}

VecBinaryTensorList::VecBinaryTensorList(const VecBinaryTensorList& other29) {
  tensor_list = other29.tensor_list;
  __isset = other29.__isset;
}
VecBinaryTensorList& VecBinaryTensorList::operator=(const VecBinaryTensorList& other30) {
  tensor_list = other30.tensor_list;
  __isset = other30.__isset;
  return *this;
}
void VecBinaryTensorList::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "VecBinaryTensorList(";
  out << "tensor_list=" << to_string(tensor_list);
  out << ")";
}


VecSearchResult::~VecSearchResult() throw() {
}


void VecSearchResult::__set_id_list(const std::vector<std::string> & val) {
  this->id_list = val;
}

void VecSearchResult::__set_distance_list(const std::vector<double> & val) {
  this->distance_list = val;
}
std::ostream& operator<<(std::ostream& out, const VecSearchResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t VecSearchResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->id_list.clear();
            uint32_t _size31;
            ::apache::thrift::protocol::TType _etype34;
            xfer += iprot->readListBegin(_etype34, _size31);
            this->id_list.resize(_size31);
            uint32_t _i35;
            for (_i35 = 0; _i35 < _size31; ++_i35)
            {
              xfer += iprot->readString(this->id_list[_i35]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.id_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->distance_list.clear();
            uint32_t _size36;
            ::apache::thrift::protocol::TType _etype39;
            xfer += iprot->readListBegin(_etype39, _size36);
            this->distance_list.resize(_size36);
            uint32_t _i40;
            for (_i40 = 0; _i40 < _size36; ++_i40)
            {
              xfer += iprot->readDouble(this->distance_list[_i40]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.distance_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t VecSearchResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("VecSearchResult");

  xfer += oprot->writeFieldBegin("id_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->id_list.size()));
    std::vector<std::string> ::const_iterator _iter41;
    for (_iter41 = this->id_list.begin(); _iter41 != this->id_list.end(); ++_iter41)
    {
      xfer += oprot->writeString((*_iter41));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("distance_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->distance_list.size()));
    std::vector<double> ::const_iterator _iter42;
    for (_iter42 = this->distance_list.begin(); _iter42 != this->distance_list.end(); ++_iter42)
    {
      xfer += oprot->writeDouble((*_iter42));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(VecSearchResult &a, VecSearchResult &b) {
  using ::std::swap;
  swap(a.id_list, b.id_list);
  swap(a.distance_list, b.distance_list);
  swap(a.__isset, b.__isset);
}

VecSearchResult::VecSearchResult(const VecSearchResult& other43) {
  id_list = other43.id_list;
  distance_list = other43.distance_list;
  __isset = other43.__isset;
}
VecSearchResult& VecSearchResult::operator=(const VecSearchResult& other44) {
  id_list = other44.id_list;
  distance_list = other44.distance_list;
  __isset = other44.__isset;
  return *this;
}
void VecSearchResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "VecSearchResult(";
  out << "id_list=" << to_string(id_list);
  out << ", " << "distance_list=" << to_string(distance_list);
  out << ")";
}


VecSearchResultList::~VecSearchResultList() throw() {
}


void VecSearchResultList::__set_result_list(const std::vector<VecSearchResult> & val) {
  this->result_list = val;
}
std::ostream& operator<<(std::ostream& out, const VecSearchResultList& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t VecSearchResultList::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->result_list.clear();
            uint32_t _size45;
            ::apache::thrift::protocol::TType _etype48;
            xfer += iprot->readListBegin(_etype48, _size45);
            this->result_list.resize(_size45);
            uint32_t _i49;
            for (_i49 = 0; _i49 < _size45; ++_i49)
            {
              xfer += this->result_list[_i49].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.result_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t VecSearchResultList::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("VecSearchResultList");

  xfer += oprot->writeFieldBegin("result_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->result_list.size()));
    std::vector<VecSearchResult> ::const_iterator _iter50;
    for (_iter50 = this->result_list.begin(); _iter50 != this->result_list.end(); ++_iter50)
    {
      xfer += (*_iter50).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(VecSearchResultList &a, VecSearchResultList &b) {
  using ::std::swap;
  swap(a.result_list, b.result_list);
  swap(a.__isset, b.__isset);
}

VecSearchResultList::VecSearchResultList(const VecSearchResultList& other51) {
  result_list = other51.result_list;
  __isset = other51.__isset;
}
VecSearchResultList& VecSearchResultList::operator=(const VecSearchResultList& other52) {
  result_list = other52.result_list;
  __isset = other52.__isset;
  return *this;
}
void VecSearchResultList::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "VecSearchResultList(";
  out << "result_list=" << to_string(result_list);
  out << ")";
}


VecDateTime::~VecDateTime() throw() {
}


void VecDateTime::__set_year(const int32_t val) {
  this->year = val;
}

void VecDateTime::__set_month(const int32_t val) {
  this->month = val;
}

void VecDateTime::__set_day(const int32_t val) {
  this->day = val;
}

void VecDateTime::__set_hour(const int32_t val) {
  this->hour = val;
}

void VecDateTime::__set_minute(const int32_t val) {
  this->minute = val;
}

void VecDateTime::__set_second(const int32_t val) {
  this->second = val;
}
std::ostream& operator<<(std::ostream& out, const VecDateTime& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t VecDateTime::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->year);
          this->__isset.year = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->month);
          this->__isset.month = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->day);
          this->__isset.day = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->hour);
          this->__isset.hour = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->minute);
          this->__isset.minute = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->second);
          this->__isset.second = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t VecDateTime::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("VecDateTime");

  xfer += oprot->writeFieldBegin("year", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->year);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("month", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->month);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("day", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->day);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hour", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->hour);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minute", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->minute);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("second", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->second);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(VecDateTime &a, VecDateTime &b) {
  using ::std::swap;
  swap(a.year, b.year);
  swap(a.month, b.month);
  swap(a.day, b.day);
  swap(a.hour, b.hour);
  swap(a.minute, b.minute);
  swap(a.second, b.second);
  swap(a.__isset, b.__isset);
}

VecDateTime::VecDateTime(const VecDateTime& other53) {
  year = other53.year;
  month = other53.month;
  day = other53.day;
  hour = other53.hour;
  minute = other53.minute;
  second = other53.second;
  __isset = other53.__isset;
}
VecDateTime& VecDateTime::operator=(const VecDateTime& other54) {
  year = other54.year;
  month = other54.month;
  day = other54.day;
  hour = other54.hour;
  minute = other54.minute;
  second = other54.second;
  __isset = other54.__isset;
  return *this;
}
void VecDateTime::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "VecDateTime(";
  out << "year=" << to_string(year);
  out << ", " << "month=" << to_string(month);
  out << ", " << "day=" << to_string(day);
  out << ", " << "hour=" << to_string(hour);
  out << ", " << "minute=" << to_string(minute);
  out << ", " << "second=" << to_string(second);
  out << ")";
}


VecTimeRange::~VecTimeRange() throw() {
}


void VecTimeRange::__set_time_begin(const VecDateTime& val) {
  this->time_begin = val;
}

void VecTimeRange::__set_begine_closed(const bool val) {
  this->begine_closed = val;
}

void VecTimeRange::__set_time_end(const VecDateTime& val) {
  this->time_end = val;
}

void VecTimeRange::__set_end_closed(const bool val) {
  this->end_closed = val;
}
std::ostream& operator<<(std::ostream& out, const VecTimeRange& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t VecTimeRange::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->time_begin.read(iprot);
          this->__isset.time_begin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->begine_closed);
          this->__isset.begine_closed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->time_end.read(iprot);
          this->__isset.time_end = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->end_closed);
          this->__isset.end_closed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t VecTimeRange::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("VecTimeRange");

  xfer += oprot->writeFieldBegin("time_begin", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->time_begin.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("begine_closed", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->begine_closed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("time_end", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->time_end.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("end_closed", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->end_closed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(VecTimeRange &a, VecTimeRange &b) {
  using ::std::swap;
  swap(a.time_begin, b.time_begin);
  swap(a.begine_closed, b.begine_closed);
  swap(a.time_end, b.time_end);
  swap(a.end_closed, b.end_closed);
  swap(a.__isset, b.__isset);
}

VecTimeRange::VecTimeRange(const VecTimeRange& other55) {
  time_begin = other55.time_begin;
  begine_closed = other55.begine_closed;
  time_end = other55.time_end;
  end_closed = other55.end_closed;
  __isset = other55.__isset;
}
VecTimeRange& VecTimeRange::operator=(const VecTimeRange& other56) {
  time_begin = other56.time_begin;
  begine_closed = other56.begine_closed;
  time_end = other56.time_end;
  end_closed = other56.end_closed;
  __isset = other56.__isset;
  return *this;
}
void VecTimeRange::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "VecTimeRange(";
  out << "time_begin=" << to_string(time_begin);
  out << ", " << "begine_closed=" << to_string(begine_closed);
  out << ", " << "time_end=" << to_string(time_end);
  out << ", " << "end_closed=" << to_string(end_closed);
  out << ")";
}


VecTimeRangeList::~VecTimeRangeList() throw() {
}


void VecTimeRangeList::__set_range_list(const std::vector<VecTimeRange> & val) {
  this->range_list = val;
}
std::ostream& operator<<(std::ostream& out, const VecTimeRangeList& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t VecTimeRangeList::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->range_list.clear();
            uint32_t _size57;
            ::apache::thrift::protocol::TType _etype60;
            xfer += iprot->readListBegin(_etype60, _size57);
            this->range_list.resize(_size57);
            uint32_t _i61;
            for (_i61 = 0; _i61 < _size57; ++_i61)
            {
              xfer += this->range_list[_i61].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.range_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t VecTimeRangeList::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("VecTimeRangeList");

  xfer += oprot->writeFieldBegin("range_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->range_list.size()));
    std::vector<VecTimeRange> ::const_iterator _iter62;
    for (_iter62 = this->range_list.begin(); _iter62 != this->range_list.end(); ++_iter62)
    {
      xfer += (*_iter62).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(VecTimeRangeList &a, VecTimeRangeList &b) {
  using ::std::swap;
  swap(a.range_list, b.range_list);
  swap(a.__isset, b.__isset);
}

VecTimeRangeList::VecTimeRangeList(const VecTimeRangeList& other63) {
  range_list = other63.range_list;
  __isset = other63.__isset;
}
VecTimeRangeList& VecTimeRangeList::operator=(const VecTimeRangeList& other64) {
  range_list = other64.range_list;
  __isset = other64.__isset;
  return *this;
}
void VecTimeRangeList::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "VecTimeRangeList(";
  out << "range_list=" << to_string(range_list);
  out << ")";
}


