#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys

from thrift.transport import TTransport
all_structs = []


class VecErrCode(object):
    SUCCESS = 0
    ILLEGAL_ARGUMENT = 1
    GROUP_NOT_EXISTS = 2
    ILLEGAL_TIME_RANGE = 3
    ILLEGAL_VECTOR_DIMENSION = 4
    OUT_OF_MEMORY = 5

    _VALUES_TO_NAMES = {
        0: "SUCCESS",
        1: "ILLEGAL_ARGUMENT",
        2: "GROUP_NOT_EXISTS",
        3: "ILLEGAL_TIME_RANGE",
        4: "ILLEGAL_VECTOR_DIMENSION",
        5: "OUT_OF_MEMORY",
    }

    _NAMES_TO_VALUES = {
        "SUCCESS": 0,
        "ILLEGAL_ARGUMENT": 1,
        "GROUP_NOT_EXISTS": 2,
        "ILLEGAL_TIME_RANGE": 3,
        "ILLEGAL_VECTOR_DIMENSION": 4,
        "OUT_OF_MEMORY": 5,
    }


class VecException(TException):
    """
    Attributes:
     - code
     - reason
    """


    def __init__(self, code=None, reason=None,):
        self.code = code
        self.reason = reason

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.code = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.reason = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('VecException')
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.I32, 1)
            oprot.writeI32(self.code)
            oprot.writeFieldEnd()
        if self.reason is not None:
            oprot.writeFieldBegin('reason', TType.STRING, 2)
            oprot.writeString(self.reason.encode('utf-8') if sys.version_info[0] == 2 else self.reason)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class VecGroup(object):
    """
    Attributes:
     - id
     - dimension
     - index_type
    """


    def __init__(self, id=None, dimension=None, index_type=None,):
        self.id = id
        self.dimension = dimension
        self.index_type = index_type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dimension = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.index_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('VecGroup')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.STRING, 1)
            oprot.writeString(self.id.encode('utf-8') if sys.version_info[0] == 2 else self.id)
            oprot.writeFieldEnd()
        if self.dimension is not None:
            oprot.writeFieldBegin('dimension', TType.I32, 2)
            oprot.writeI32(self.dimension)
            oprot.writeFieldEnd()
        if self.index_type is not None:
            oprot.writeFieldBegin('index_type', TType.I32, 3)
            oprot.writeI32(self.index_type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.id is None:
            raise TProtocolException(message='Required field id is unset!')
        if self.dimension is None:
            raise TProtocolException(message='Required field dimension is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class VecTensor(object):
    """
    Attributes:
     - uid
     - tensor
     - attrib
    """


    def __init__(self, uid=None, tensor=None, attrib=None,):
        self.uid = uid
        self.tensor = tensor
        self.attrib = attrib

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.uid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.tensor = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = iprot.readDouble()
                        self.tensor.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.attrib = {}
                    (_ktype7, _vtype8, _size6) = iprot.readMapBegin()
                    for _i10 in range(_size6):
                        _key11 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val12 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.attrib[_key11] = _val12
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('VecTensor')
        if self.uid is not None:
            oprot.writeFieldBegin('uid', TType.STRING, 1)
            oprot.writeString(self.uid.encode('utf-8') if sys.version_info[0] == 2 else self.uid)
            oprot.writeFieldEnd()
        if self.tensor is not None:
            oprot.writeFieldBegin('tensor', TType.LIST, 2)
            oprot.writeListBegin(TType.DOUBLE, len(self.tensor))
            for iter13 in self.tensor:
                oprot.writeDouble(iter13)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.attrib is not None:
            oprot.writeFieldBegin('attrib', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.attrib))
            for kiter14, viter15 in self.attrib.items():
                oprot.writeString(kiter14.encode('utf-8') if sys.version_info[0] == 2 else kiter14)
                oprot.writeString(viter15.encode('utf-8') if sys.version_info[0] == 2 else viter15)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.uid is None:
            raise TProtocolException(message='Required field uid is unset!')
        if self.tensor is None:
            raise TProtocolException(message='Required field tensor is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class VecTensorList(object):
    """
    Attributes:
     - tensor_list
    """


    def __init__(self, tensor_list=None,):
        self.tensor_list = tensor_list

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.tensor_list = []
                    (_etype19, _size16) = iprot.readListBegin()
                    for _i20 in range(_size16):
                        _elem21 = VecTensor()
                        _elem21.read(iprot)
                        self.tensor_list.append(_elem21)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('VecTensorList')
        if self.tensor_list is not None:
            oprot.writeFieldBegin('tensor_list', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.tensor_list))
            for iter22 in self.tensor_list:
                iter22.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.tensor_list is None:
            raise TProtocolException(message='Required field tensor_list is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class VecBinaryTensor(object):
    """
    Attributes:
     - uid
     - tensor
     - attrib
    """


    def __init__(self, uid=None, tensor=None, attrib=None,):
        self.uid = uid
        self.tensor = tensor
        self.attrib = attrib

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.uid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tensor = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.attrib = {}
                    (_ktype24, _vtype25, _size23) = iprot.readMapBegin()
                    for _i27 in range(_size23):
                        _key28 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val29 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.attrib[_key28] = _val29
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('VecBinaryTensor')
        if self.uid is not None:
            oprot.writeFieldBegin('uid', TType.STRING, 1)
            oprot.writeString(self.uid.encode('utf-8') if sys.version_info[0] == 2 else self.uid)
            oprot.writeFieldEnd()
        if self.tensor is not None:
            oprot.writeFieldBegin('tensor', TType.STRING, 2)
            oprot.writeBinary(self.tensor)
            oprot.writeFieldEnd()
        if self.attrib is not None:
            oprot.writeFieldBegin('attrib', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.attrib))
            for kiter30, viter31 in self.attrib.items():
                oprot.writeString(kiter30.encode('utf-8') if sys.version_info[0] == 2 else kiter30)
                oprot.writeString(viter31.encode('utf-8') if sys.version_info[0] == 2 else viter31)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.uid is None:
            raise TProtocolException(message='Required field uid is unset!')
        if self.tensor is None:
            raise TProtocolException(message='Required field tensor is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class VecBinaryTensorList(object):
    """
    Attributes:
     - tensor_list
    """


    def __init__(self, tensor_list=None,):
        self.tensor_list = tensor_list

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.tensor_list = []
                    (_etype35, _size32) = iprot.readListBegin()
                    for _i36 in range(_size32):
                        _elem37 = VecBinaryTensor()
                        _elem37.read(iprot)
                        self.tensor_list.append(_elem37)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('VecBinaryTensorList')
        if self.tensor_list is not None:
            oprot.writeFieldBegin('tensor_list', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.tensor_list))
            for iter38 in self.tensor_list:
                iter38.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.tensor_list is None:
            raise TProtocolException(message='Required field tensor_list is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class VecSearchResultItem(object):
    """
    Attributes:
     - uid
     - distance
     - attrib
    """


    def __init__(self, uid=None, distance=None, attrib=None,):
        self.uid = uid
        self.distance = distance
        self.attrib = attrib

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.uid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.distance = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.attrib = {}
                    (_ktype40, _vtype41, _size39) = iprot.readMapBegin()
                    for _i43 in range(_size39):
                        _key44 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val45 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.attrib[_key44] = _val45
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('VecSearchResultItem')
        if self.uid is not None:
            oprot.writeFieldBegin('uid', TType.STRING, 1)
            oprot.writeString(self.uid.encode('utf-8') if sys.version_info[0] == 2 else self.uid)
            oprot.writeFieldEnd()
        if self.distance is not None:
            oprot.writeFieldBegin('distance', TType.DOUBLE, 2)
            oprot.writeDouble(self.distance)
            oprot.writeFieldEnd()
        if self.attrib is not None:
            oprot.writeFieldBegin('attrib', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.attrib))
            for kiter46, viter47 in self.attrib.items():
                oprot.writeString(kiter46.encode('utf-8') if sys.version_info[0] == 2 else kiter46)
                oprot.writeString(viter47.encode('utf-8') if sys.version_info[0] == 2 else viter47)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.uid is None:
            raise TProtocolException(message='Required field uid is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class VecSearchResult(object):
    """
    Attributes:
     - result_list
    """


    def __init__(self, result_list=None,):
        self.result_list = result_list

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.result_list = []
                    (_etype51, _size48) = iprot.readListBegin()
                    for _i52 in range(_size48):
                        _elem53 = VecSearchResultItem()
                        _elem53.read(iprot)
                        self.result_list.append(_elem53)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('VecSearchResult')
        if self.result_list is not None:
            oprot.writeFieldBegin('result_list', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.result_list))
            for iter54 in self.result_list:
                iter54.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class VecSearchResultList(object):
    """
    Attributes:
     - result_list
    """


    def __init__(self, result_list=None,):
        self.result_list = result_list

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.result_list = []
                    (_etype58, _size55) = iprot.readListBegin()
                    for _i59 in range(_size55):
                        _elem60 = VecSearchResult()
                        _elem60.read(iprot)
                        self.result_list.append(_elem60)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('VecSearchResultList')
        if self.result_list is not None:
            oprot.writeFieldBegin('result_list', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.result_list))
            for iter61 in self.result_list:
                iter61.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class VecDateTime(object):
    """
    second;			Seconds.	[0-60] (1 leap second)
    minute;			Minutes.	[0-59]
    hour;			Hours.	    [0-23]
    day;			    Day.		[1-31]
    month;			Month.	    [0-11]
    year;			Year - 1900.

    Attributes:
     - year
     - month
     - day
     - hour
     - minute
     - second
    """


    def __init__(self, year=None, month=None, day=None, hour=None, minute=None, second=None,):
        self.year = year
        self.month = month
        self.day = day
        self.hour = hour
        self.minute = minute
        self.second = second

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.year = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.month = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.day = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.hour = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.minute = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.second = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('VecDateTime')
        if self.year is not None:
            oprot.writeFieldBegin('year', TType.I32, 1)
            oprot.writeI32(self.year)
            oprot.writeFieldEnd()
        if self.month is not None:
            oprot.writeFieldBegin('month', TType.I32, 2)
            oprot.writeI32(self.month)
            oprot.writeFieldEnd()
        if self.day is not None:
            oprot.writeFieldBegin('day', TType.I32, 3)
            oprot.writeI32(self.day)
            oprot.writeFieldEnd()
        if self.hour is not None:
            oprot.writeFieldBegin('hour', TType.I32, 4)
            oprot.writeI32(self.hour)
            oprot.writeFieldEnd()
        if self.minute is not None:
            oprot.writeFieldBegin('minute', TType.I32, 5)
            oprot.writeI32(self.minute)
            oprot.writeFieldEnd()
        if self.second is not None:
            oprot.writeFieldBegin('second', TType.I32, 6)
            oprot.writeI32(self.second)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.year is None:
            raise TProtocolException(message='Required field year is unset!')
        if self.month is None:
            raise TProtocolException(message='Required field month is unset!')
        if self.day is None:
            raise TProtocolException(message='Required field day is unset!')
        if self.hour is None:
            raise TProtocolException(message='Required field hour is unset!')
        if self.minute is None:
            raise TProtocolException(message='Required field minute is unset!')
        if self.second is None:
            raise TProtocolException(message='Required field second is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class VecTimeRange(object):
    """
    time_begin;          time range begin
    begine_closed;	    true means '[', false means '('
    time_end;            set to true to return tensor double array
    end_closed;          time range end

    Attributes:
     - time_begin
     - begine_closed
     - time_end
     - end_closed
    """


    def __init__(self, time_begin=None, begine_closed=None, time_end=None, end_closed=None,):
        self.time_begin = time_begin
        self.begine_closed = begine_closed
        self.time_end = time_end
        self.end_closed = end_closed

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.time_begin = VecDateTime()
                    self.time_begin.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.begine_closed = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.time_end = VecDateTime()
                    self.time_end.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.end_closed = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('VecTimeRange')
        if self.time_begin is not None:
            oprot.writeFieldBegin('time_begin', TType.STRUCT, 1)
            self.time_begin.write(oprot)
            oprot.writeFieldEnd()
        if self.begine_closed is not None:
            oprot.writeFieldBegin('begine_closed', TType.BOOL, 2)
            oprot.writeBool(self.begine_closed)
            oprot.writeFieldEnd()
        if self.time_end is not None:
            oprot.writeFieldBegin('time_end', TType.STRUCT, 3)
            self.time_end.write(oprot)
            oprot.writeFieldEnd()
        if self.end_closed is not None:
            oprot.writeFieldBegin('end_closed', TType.BOOL, 4)
            oprot.writeBool(self.end_closed)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.time_begin is None:
            raise TProtocolException(message='Required field time_begin is unset!')
        if self.begine_closed is None:
            raise TProtocolException(message='Required field begine_closed is unset!')
        if self.time_end is None:
            raise TProtocolException(message='Required field time_end is unset!')
        if self.end_closed is None:
            raise TProtocolException(message='Required field end_closed is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class VecSearchFilter(object):
    """
    attrib_filter;   search condition, for example: "color=red"
    time_ranges;	    search condition, for example: "date between 1999-02-12 and 2008-10-14"
    return_attribs;  specify required attribute names

    Attributes:
     - attrib_filter
     - time_ranges
     - return_attribs
    """


    def __init__(self, attrib_filter=None, time_ranges=None, return_attribs=None,):
        self.attrib_filter = attrib_filter
        self.time_ranges = time_ranges
        self.return_attribs = return_attribs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.attrib_filter = {}
                    (_ktype63, _vtype64, _size62) = iprot.readMapBegin()
                    for _i66 in range(_size62):
                        _key67 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val68 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.attrib_filter[_key67] = _val68
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.time_ranges = []
                    (_etype72, _size69) = iprot.readListBegin()
                    for _i73 in range(_size69):
                        _elem74 = VecTimeRange()
                        _elem74.read(iprot)
                        self.time_ranges.append(_elem74)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.return_attribs = []
                    (_etype78, _size75) = iprot.readListBegin()
                    for _i79 in range(_size75):
                        _elem80 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.return_attribs.append(_elem80)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('VecSearchFilter')
        if self.attrib_filter is not None:
            oprot.writeFieldBegin('attrib_filter', TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.attrib_filter))
            for kiter81, viter82 in self.attrib_filter.items():
                oprot.writeString(kiter81.encode('utf-8') if sys.version_info[0] == 2 else kiter81)
                oprot.writeString(viter82.encode('utf-8') if sys.version_info[0] == 2 else viter82)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.time_ranges is not None:
            oprot.writeFieldBegin('time_ranges', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.time_ranges))
            for iter83 in self.time_ranges:
                iter83.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.return_attribs is not None:
            oprot.writeFieldBegin('return_attribs', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.return_attribs))
            for iter84 in self.return_attribs:
                oprot.writeString(iter84.encode('utf-8') if sys.version_info[0] == 2 else iter84)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(VecException)
VecException.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'code', None, None, ),  # 1
    (2, TType.STRING, 'reason', 'UTF8', None, ),  # 2
)
all_structs.append(VecGroup)
VecGroup.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'id', 'UTF8', None, ),  # 1
    (2, TType.I32, 'dimension', None, None, ),  # 2
    (3, TType.I32, 'index_type', None, None, ),  # 3
)
all_structs.append(VecTensor)
VecTensor.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'uid', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'tensor', (TType.DOUBLE, None, False), None, ),  # 2
    (3, TType.MAP, 'attrib', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 3
)
all_structs.append(VecTensorList)
VecTensorList.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'tensor_list', (TType.STRUCT, [VecTensor, None], False), None, ),  # 1
)
all_structs.append(VecBinaryTensor)
VecBinaryTensor.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'uid', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tensor', 'BINARY', None, ),  # 2
    (3, TType.MAP, 'attrib', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 3
)
all_structs.append(VecBinaryTensorList)
VecBinaryTensorList.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'tensor_list', (TType.STRUCT, [VecBinaryTensor, None], False), None, ),  # 1
)
all_structs.append(VecSearchResultItem)
VecSearchResultItem.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'uid', 'UTF8', None, ),  # 1
    (2, TType.DOUBLE, 'distance', None, None, ),  # 2
    (3, TType.MAP, 'attrib', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 3
)
all_structs.append(VecSearchResult)
VecSearchResult.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'result_list', (TType.STRUCT, [VecSearchResultItem, None], False), None, ),  # 1
)
all_structs.append(VecSearchResultList)
VecSearchResultList.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'result_list', (TType.STRUCT, [VecSearchResult, None], False), None, ),  # 1
)
all_structs.append(VecDateTime)
VecDateTime.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'year', None, None, ),  # 1
    (2, TType.I32, 'month', None, None, ),  # 2
    (3, TType.I32, 'day', None, None, ),  # 3
    (4, TType.I32, 'hour', None, None, ),  # 4
    (5, TType.I32, 'minute', None, None, ),  # 5
    (6, TType.I32, 'second', None, None, ),  # 6
)
all_structs.append(VecTimeRange)
VecTimeRange.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'time_begin', [VecDateTime, None], None, ),  # 1
    (2, TType.BOOL, 'begine_closed', None, None, ),  # 2
    (3, TType.STRUCT, 'time_end', [VecDateTime, None], None, ),  # 3
    (4, TType.BOOL, 'end_closed', None, None, ),  # 4
)
all_structs.append(VecSearchFilter)
VecSearchFilter.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'attrib_filter', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.LIST, 'time_ranges', (TType.STRUCT, [VecTimeRange, None], False), None, ),  # 2
    (3, TType.LIST, 'return_attribs', (TType.STRING, 'UTF8', False), None, ),  # 3
)
fix_spec(all_structs)
del all_structs
